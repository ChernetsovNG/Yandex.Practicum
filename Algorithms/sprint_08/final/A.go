package main

/*
https://contest.yandex.ru/contest/26133/run-report/64673026/

-- ПРИНЦИП РАБОТЫ --

В целом эта задача состоит из двух частей:
- распаковывать запакованные строки, заданные рекурсивно;
- определять наибольший общий префикс массива строк

Для распаковки запакованной строки и превращения её в обычную строку используем рекурсивный подход.

Для определения наибольшего общего префикса массива строк используем следующий подход:
- вначале считаем наибольшим префиксом первую строку;
- затем идём по списку строк, и находим общий префикс текущей строки и наибольшего общего префикса,
  вычисленного к настоящему моменту.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

1. При прохождении по символам запакованной строки возможны три варианта:
- мы встречаем обычный символ латинского алфавита;
- мы встречаем цифру со следующей за ней открывающей квадратной скобкой;
- мы встречаем закрывающую квадратную скобку.

В соответствии с этим собираем результирующую распакованную строку:
- если встречаем обычный символ, то добавляем его к результату;
- если встречаем цифру со следующей за ней открывающей квадратной скобкой, то входим в рекурсию, передавая в неё
  остаток строки после открывающей квадратной скобки. Возвращённый из рекурсивного вызова результат прибавляем
  заданное количество раз к результату;
- если встречаем закрывающую квадратную скобку, то возвращаем набранные символы на предыдущий шаг рекурсии. Кроме того,
  возвращаем количество символов, просмотренное на текущем шаге рекурсии, чтобы сдвинуть указатель на нужную позицию
  в предыдущем шаге рекурсии (чтобы не проходить одни и те же символы несколько раз).

2. При вычислении общего префикса двух строк идём по символам строк до тех пор, пока не встретим первый
не совпадающий символ. Символы до не совпадающего являются общим префиксом. Мы идём по всем строкам из списка
распакованных строк, постепенно уточняя общий префикс для каждой новой строки.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Временная сложность распаковки строки пропорциональна количеству символов в записи запакованной строки, т.е. O(n).
Т.к. мы обходим в цикле все её символы, а если встречаем открывающую скобку, то переходим в рекурсивный вызов,
в который передаём более короткую строку, а при возврате из рекурсивного вызова смещаем указатель цикла на нужную
позицию после закрывающей квадратной скобки.

Временная сложность поиска наибольшего общего префикса в массиве из k строк в худшем случае равна O(n*k), т.к.
если все k строк одинаковые и состоят из n символов, то на каждом шаге цикла нам надо будет проверить на
совпадение все n символов. В случае же, когда строки различаются, длина наибольшего общего префикса будет постепенно
уменьшаться, а значит на каждом шаге цикла нам надо будет проверять всё меньше символов. Оценить сложность в среднем
случае достаточно сложно.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

При распаковке каждой запакованной строки мы сохраняем результат в массив символов. Суммарное количество памяти
для всех таких k строк составит O(n*k), где n - среднее количество символов в распакованных строках. Т.е. потребная
память будет равна суммарному количеству символов в распакованных строках. Плюс некоторое постоянное количество памяти
потребуется для хранения наибольшего общего префикса, но оно не превышает длины самой длинной распакованной строки.
*/

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	const maxCapacity = 8 * 100000
	buffer := make([]byte, maxCapacity)
	scanner.Buffer(buffer, maxCapacity)

	// читаем число строк
	var n int

	scanner.Scan()
	line := scanner.Text()
	n, _ = strconv.Atoi(line)

	// читаем запакованные строки и распаковываем их

	// сперва наибольший общий префикс - первая строка
	scanner.Scan()
	prefix, _ := unpack([]rune(scanner.Text()))

	for i := 1; i < n; i++ {
		scanner.Scan()
		line, _ := unpack([]rune(scanner.Text()))
		minLen := min(len(prefix), len(line))
		var j int
		for j = 0; j < minLen; j++ {
			if prefix[j] != line[j] {
				break
			}
		}
		prefix = line[0:j]
	}

	// выводим наибольший общий префикс распакованных строк
	fmt.Print(string(prefix))
}

// функция распаковки строки
// возвращает распакованную строку и индекс закрывающей скобки
func unpack(packed []rune) ([]rune, int) {
	var result []rune
	n := len(packed)

	for i := 0; i < n; i++ {
		packedSymbol := packed[i]
		if isDigit(packedSymbol) && i < n {
			nextSymbol := packed[i+1]
			if isOpenSquareBracket(nextSymbol) {
				// вход в рекурсию: n[...
				recurseSymbols := packed[i+2:]
				recurseUnpack, closeBracketIndex := unpack(recurseSymbols)
				n := toDigit(packedSymbol)
				for j := 0; j < n; j++ {
					result = append(result, recurseUnpack...)
				}
				// смещаем индекс после последней закрывающей скобки,
				// чтобы не проходить заново рассмотренный участок строки
				i += closeBracketIndex + 2
			}
		} else if isCloseSquareBracket(packedSymbol) {
			// ] - выход из рекурсии на предыдущий уровень
			return result, i
		} else {
			// обычный символ
			result = append(result, packedSymbol)
		}
	}

	return result, -1
}

// символ - число 0, 1, ..., 9
func isDigit(r rune) bool {
	i := int(r)
	return 48 <= i && i <= 57
}

// символ - открывающая квадратная скобка [
func isOpenSquareBracket(r rune) bool {
	i := int(r)
	return i == 91
}

// символ - закрывающая квадратная скобка ]
func isCloseSquareBracket(r rune) bool {
	i := int(r)
	return i == 93
}

// chr(48) - 0, ..., chr(57) - 9
func toDigit(r rune) int {
	return int(r) - 48
}

func min(x, y int) int {
	if x < y {
		return x
	} else {
		return y
	}
}
