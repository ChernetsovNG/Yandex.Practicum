package main

/*
https://contest.yandex.ru/contest/23815/run-report/53191532/

-- ПРИНЦИП РАБОТЫ --
Рассмотрим какой-нибудь упорядоченный массив, например
[0 2 4 8 10]
Выполним для него все возможные сдвиги:
[10 0 2 4 8]
[8 10 0 2 4]
[4 8 10 0 2]
[2 4 8 10 0]

Можно заметить (и это ключевая идея алгоритма), что при любом таком сдвиге либо левая (в случаях 3 и 4),
либо правая (в случаях 1 и 2) половина массива оказываются упорядоченными.
На каждом шаге поиска мы проверяем, какая половина массива упорядочена. Далее проверяем, попадает ли искомый элемент
в эту половину. Если попадает, то рекурсивно ищем элемент в ней. А если не попадает, то рекурсивно ищем элемент
в другой половине.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Нужно доказать, что при любом циклическом сдвиге упорядоченного массива одна из его половин оказывается упорядоченной.
Математически корректно это доказать сложно, но можно заметить. Например, рассмотрим массив из 6-ти упорядоченных
элементов: [a1 a2 a3 a4 a5 a6]. Обе его половины упорядочены: [a1 a2 a3], [a4 a5 a6]. Когда мы сдвигаем массив вправо,
последний элемент из левой половины "переезжает" направо, а последний элемент из правой половины - налево, в начало.
Получается: [a6 a1 a2], [a3 a4 a5]. Правый массив по-прежнему упорядочен. Делаем второй сдвиг => [a5 a6 a1], [a2 a3 a4].
Правый массив снова упорядочен. Делаем третий сдвиг => [a4 a5 a6], [a1 a2 a3]. Правый массив снова упорядочен, как,
впрочем, и левый. Можно сказать, что половины поменялись местами. Делаем четвёртый сдвиг => [a3 a4 a5], [a6 a1 a2].
Теперь последний элемент массива переехал в начало правой половины, и она перестала быть упорядоченной. Но упорядоченной
остаётся левая половина. Ясно, что если продолжать такой процесс, то будет периодически упорядоченной то левая половина,
то правая, то сразу обе, и это доказывает основную идею алгоритма.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
При поиске мы каждый раз отбрасываем половину элементов, продолжая поиск во второй половине, и каждый раз размер
пространства поиска уменьшается в 2 раза. Это классический бинарный поиск с временной сложностью O(log n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Какие-либо дополнительные массивы, помимо исходного массива размера n, в алгоритме не используются.
Поэтому пространственная сложность равна O(n).
*/

import "fmt"

func search(arr []int, left, right, k int) int {
	if right < left {
		return -1
	}
	mid := (left + right) / 2
	if k == arr[mid] { // искомый элемент найден
		return mid
	}

	if arr[left] <= arr[mid] { // 1. левая половина массива упорядочена
		if arr[left] <= k && k <= arr[mid] { // 1.1. и искомый элемент лежит в левой половине
			return search(arr, left, mid-1, k) // => ищем в левой половине
		} else { // 1.2. но искомый элемент не лежит в левой половине
			return search(arr, mid+1, right, k) // => ищем в правой половине
		}
	} else { // 2. правая половина массива упорядочена
		if arr[mid] <= k && k <= arr[right] { // 2.1. и искомый элемент лежит в правой половине
			return search(arr, mid+1, right, k) // => ищем в правой половине
		} else { // 2.2. но искомый элемент не лежит в правой половине
			return search(arr, left, mid-1, k) // => ищем в левой половине
		}
	}
}

func brokenSearch(arr []int, k int) int {
	return search(arr, 0, len(arr)-1, k)
}

func test() {
	arr := []int{8, 10, 0, 2, 4}
	if brokenSearch(arr, 4) != 4 {
		panic("WA")
	} else {
		fmt.Print("Good!")
	}
}
