package main

/*
https://contest.yandex.ru/contest/23815/run-report/53197070/

-- ПРИНЦИП РАБОТЫ --
Основа метода - процесс разбиения, который переупорядочивает массив так, чтобы выполнялись три условия:
- элементы a[j] для некоторого j находится в массиве на своём окончательном месте;
- элементы от a[lo] до a[j-1] не больше a[j];
- элементы от a[j+1] до a[hi] не меньше a[j].
Для полного упорядочивания всего массива выполняется разбиение, а затем рекурсивное применение метода.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Поскольку процесс разбиения всегда помещает один элемент на своё окончательное место в массиве, то ясно, что в итоге
он упорядочит весь массив.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Операция разделения массива на две части относительно опорного элемента занимает время O(log n).
Поскольку все операции разделения, проделываемые на одной глубине рекурсии, обрабатывают разные части исходного массива,
размер которого постоянен и равен n, то суммарно на каждом уровне рекурсии потребуется также O(n) операций.
Следовательно, общая сложность алгоритма определяется лишь количеством разделений, то есть глубиной рекурсии.
Глубина рекурсии зависит от сочетания входных данных и способа определения опорного элемента.

В лучшем случае при каждой операции разделения массив делится на две одинаковы части, следовательно,
максимальная глубина рекурсии, при которой размеры обрабатываемых подмассивов достигнут 1, составляет O(log n).
В результате общая сложность алгоритма составит O(n*lon(n)).

В худшем случае каждое разделение даёт два подмассива размерами 1 и n-1, то есть при каждом рекурсивном вызове
больший массив будет на 1 короче, чем в предыдущий раз. Такое может произойти, если в качестве опорного на каждом
этапе будет выбран элемент либо наименьший, либо наибольший элемент из всех обрабатываемых.
В этом случае потребуется n-1 операций разделения, а общее время работы составит O(n^2).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Какие-либо дополнительные массивы в алгоритме не используются, сортировка выполняется на месте.
Поэтому пространственная сложность равна O(1).
*/

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type participant struct {
	login string
	p     int
	f     int
}

/*
при сравнении двух участников выше будет идти тот, у которого решено больше задач. При равенстве
числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, то первым
будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке
*/
func cmp(p1 participant, p2 participant) int {
	if p1.p > p2.p {
		return 1
	} else if p1.p < p2.p {
		return -1
	} else { // число решённых задач одинаково
		if p1.f < p2.f {
			return 1
		} else if p1.f > p2.f {
			return -1
		} else { // штрафы одинаковые
			if p1.login < p2.login {
				return 1
			} else if p1.login > p2.login {
				return -1
			} else { // равны все параметры участников
				return 0
			}
		}
	}
}

func quicksort(a []participant, lo, hi int) {
	if hi <= lo {
		return
	}
	j := partition(a, lo, hi)
	quicksort(a, lo, j-1)
	quicksort(a, j+1, hi)
}

/*
Метод помещает a[j] на своё место в отсортированном массиве, и переупорядочивает остальные элементы так, что в левой
половине все элементы меньше или равны a[j], а в правой - больше или равны
*/
func partition(a []participant, lo, hi int) int {
	// левый и правый индексы просмотра
	i := lo
	j := hi + 1
	v := a[lo] // опорный элемент (произвольно выбираем первый элемент)

	var compareResult int
	for {
		// просматриваем элементы с левого конца, пока не найдём элемент, который больше или равен опорного
		for {
			i += 1
			compareResult = cmp(a[i], v)
			if compareResult == 0 || compareResult == 1 {
				break
			}
			if i == hi {
				break
			}
		}

		// просматриваем элементы с правого конца, пока не найдём элементы, который меньше или равен опорного
		for {
			j -= 1
			compareResult = cmp(v, a[j])
			if compareResult == 0 || compareResult == 1 {
				break
			}
			if j == lo {
				break
			}
		}

		// проверка на завершение
		if i >= j {
			break
		}

		// обмен
		swap(a, i, j)
	}

	// Помещение опорного элемента на своё место так, что в итоге a[lo...i-1] <= a[i] <= a[i+1...hi]
	swap(a, lo, j)
	return j
}

// меняет местами элементы с индексами j, j в массиве a
func swap(a []participant, i, j int) {
	tmp := a[i]
	a[i] = a[j]
	a[j] = tmp
}

func main() {
	scanner := bufio.NewScanner(bufio.NewReader(os.Stdin))
	const maxCapacity = 32 * 10_000
	buffer := make([]byte, maxCapacity)
	scanner.Buffer(buffer, maxCapacity)

	var line string

	// читаем количество участников
	var n int

	scanner.Scan()
	line = scanner.Text()
	n, _ = strconv.Atoi(line)

	// читаем данные по участникам
	participants := make([]participant, n)

	var login string
	var p, f int

	for i := 0; i < n; i++ {
		scanner.Scan()
		row := scanner.Text()
		values := strings.Split(row, " ")
		login = values[0]
		p, _ = strconv.Atoi(values[1])
		f, _ = strconv.Atoi(values[2])
		participants[i] = participant{login, p, f}
	}

	// сортируем участников по возрастанию
	quicksort(participants, 0, n-1)

	// выводим в обратном порядке: от лучшего к худшему
	for i := len(participants) - 1; i >= 0; i-- {
		fmt.Println(participants[i].login)
	}
}
