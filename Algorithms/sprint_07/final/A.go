package main

/*
https://contest.yandex.ru/contest/25597/run-report/63633502/

-- ПРИНЦИП РАБОТЫ --

Используем алгоритм динамического программирования и постепенно вычисляем расстояние редактирования
между подстроками первой и второй строк, пока, наращивая длину подстрок, не дойдём до расстояние
редактирования между целыми строками. При этом вычислении мы опираемся на ранее вычисленные результаты,
выбирая оптимальное (минимальное) количество операций на каждом шаге

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Рассмотрим все возможные варианты двух строк:
- если обе строки пусты, то расстояние редактирования равно нулю;
- если одна из строк пуста, то, чтобы получить её из второй (непустой) строки, нужно совершить
  количество операций удаления, равное количеству символов во второй строке;
- нетривиальный случай, когда обе строки непусты. Рассмотрим его подробно.

Обозначим через D(i,j) расстояние редактирования между подстроками длины i и j исходных строк.

Отметим, что в оптимальной последовательности операций их можно менять местами.

Пусть S1 оканчивается на символ "a", а S2 оканчивается на символ "b". Есть три варианта, как S1 превратилась в S2:

1. Символ "a" в S1 в какой-то момент был стёрт. Сделаем это стирание первой операцией. Сотрём символ "a" из строки S1.
Далее превратим первые i-1 символов S1 в S2, что потребует D(i-1, j) операций.
Значит, всего потребуется D(i-1,j)+1 операций.

2. Символ "b" в S2 в какой-то момент был добавлен. Сделаем это добавление последней операцией.
Превратим S1 в первые j-1 символов S2, что потребует D(i,j-1) операций. После этого добавим в конец символ "b".
Всего потребуется D(i,j-1)+1 операций.

3. Утверждения 1 и 2 неверны. Если мы добавляли символы справа от финального "a", то, чтобы сделать последним
символ "b", мы должны были в какой-то момент добавить его, (но тогда утверждение 2 было бы верно), либо заменить
на него один из этих добавленных символов (что тоже невозможно, потому что добавление символа с его последующей
заменой неоптимально). Значит, символов справа от финального "a" мы не добавляли. Самого финального "a" мы не
стирали, т.к. утверждение 1 неверно. Значит, единственный способ изменения последнего символа - его замена.
Заменять его 2 или более раз - неоптимально. Значит, он был заменён только 1 раз.

В итоге:
- если "a" = "b", то последний символ мы не меняли. Поскольку мы его также не стирали и не приписывали ничего
справа от него, то он не влиял на наши действия, и, значит, мы выполнили всего D(i-1,j-1) операций;
- если "a" != "b", то последний символ мы меняли один раз. Сделаем эту замену первой операцией. Далее нам
нужно выполнить D(i-1,j-1) операций, значит, всего потребуется D(i-1,j-1)+1 операций.

На каждом шаге алгоритма рассматриваем минимум из этих трёх вариантов действий.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Обозначим M - длину первой строки, N - длину второй строки. Мы делаем M + N действий для заполнения массива
для базового случая. Далее мы делаем M*N действий, используя вложенный цикл для заполнения таблицы. Таким образом,
временная сложность составляет O(M*N).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Мы оперируем двумерной таблицей размера M*N, и имеем пространственную сложность O(M*N).
*/

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	// читаем строки s и t
	var s, t string

	scanner.Scan()
	s = scanner.Text()

	scanner.Scan()
	t = scanner.Text()

	/*
	 dp[i][j] — расстояние редактирования между префиксами строк:
	 a[:i] (до символа i) и b[:j] (до символа j)
	*/
	dp := make([][]int, len(s)+1)
	for i := range dp {
		dp[i] = make([]int, len(t)+1)
	}

	// Базовый случай:
	// если вторая строка пустая, то нужно удалить все символы из первой строки, и наоборот
	for i := 0; i < len(s)+1; i++ {
		dp[i][0] = i
	}

	for j := 0; j < len(t)+1; j++ {
		dp[0][j] = j
	}

	// Рассматриваем различные варианты, как префикс a[:j] мог быть получен из префикса b[:i]
	// при помощи разрешённых операций
	for i := 1; i < len(s)+1; i++ {
		for j := 1; j < len(t)+1; j++ {
			// 1. Если последние символы префиксов совпадают, то в этом случае можно не менять эти последние символы
			if s[i-1] == t[j-1] {
				// 3. Мы можем взять префикс a[:i-1] и превратить его в b[:j] за dp[i-1][j] операций, и затем
				// добавить в конец символ a[i-1]

				// 4. Мы можем взять префикс a[:i] и превратить его в b[:j-1] за dp[i][j-1] операций, и затем
				// добавить в конец символ b[j-1]

				// берём минимальное расстояние редактирования из всех вариантов
				dp[i][j] = minOf3(dp[i-1][j-1], dp[i-1][j]+1, dp[i][j-1]+1)
			} else {
				// 2. Если последние символы не совпадают, то тогда можно потратить 1 операцию на замену
				// символа a[i-1] на b[j-1]
				dp[i][j] = minOf3(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)
			}
		}
	}

	fmt.Print(dp[len(s)][len(t)])
}

func minOf3(x, y, z int) int {
	return min(min(x, y), z)
}

func min(x, y int) int {
	if x < y {
		return x
	} else {
		return y
	}
}
