package main

import (
	"bufio"
	"os"
	"strconv"
	"strings"
)

/*
https://contest.yandex.ru/contest/25597/run-report/63862641/

-- ПРИНЦИП РАБОТЫ --

Используем алгоритм динамического программирования и постепенно вычисляем, существует ли такое подмножество
элементов из исходного множества, которые в сумме дают некоторое значение i. В конце определяем, существует
ли такое подмножество из всех элементов исходного множества, которые в сумме дают значеие k/2, где k -
сумма всех элементов множества. Если такое подмножество существует, значит исходное множество можно
разбить на два подмножества с одинаковой суммой, равной k/2.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Обозначим через K сумму элементов множества. Если она нечётна, то разбить его на 2 равных половины невозможно.
Поэтому рассмотрим случай, когда K - чётно. Мы хотим определить, существует ли подмножество S, сумма элементов
которого равна K/2. Обозначим dp[i][j] - таблицу значений такую, что dp[i][j] = True, если среди элементов
{x1, ..., xj} существует такое подмножество, элементы которого в сумме дают i, и False - если такого
подмножества не существует. Тогда dp[K/2][n] принимает значение True тогда и только тогда, когда существует
подмножество S, сумма элементов которого равна K/2. Цель нашего алгоритма - вычислить значение dp[K/2][n].

Справедливы следующие рекуррентные формулы:
- dp[i][j] принимает значение True, если либо dp[i][j-1] принимает значение True, либо dp[i-xj][j-1] принимает
значение True (потому что если существует подмножество {x1, ..., x_j-1}, в сумме дающее значение i-xj, то
если добавить к нему элемент xj, то как раз получится нужная сумма i);
- dp[i][j] принимает значение False в противном случае.

Используя эти соотношения, заполняем всю таблицу, и находим ответ. При этом dp[0][x] = True для любого x,
потому что набрать нулевую сумму всегда можно, взяв пустое подмножество. Также dp[x][0] = False для
любого x (кроме 0), потому что нельзя набрать никакую сумму (кроме 0), используя пустое подмножество.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Заполнение таблицы происходит во вложенном цикле, за количество операций k/2 * n. Таким образом,
временная сложность составляет O(k * n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Мы оперируем двумерной таблицей размера (k/2 + 1) * (n+1), поэтому и пространственная сложность
также составляет O(k * n).
*/

import (
	"fmt"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)

	var line string

	// читаем количество выигранных партий
	var n int

	scanner.Scan()
	line = scanner.Text()

	n, _ = strconv.Atoi(line)

	// читаем заработанные в партиях очки, и вычисляем сумму очков во всех партиях k
	scanner.Scan()
	line = scanner.Text()
	values := strings.Split(line, " ")

	a := make([]int, n+1)
	k := 0

	for i := 0; i < n; i++ {
		value, _ := strconv.Atoi(values[i])
		a[i+1] = value
		k += value
	}

	// если сумма очков нечётная, то разделить её на две равные половины заведомо невозможно
	if k%2 == 1 {
		fmt.Print("False")
		return
	}

	/*
	 dp[i][j] — принимает значение True, если среди {a_1, ..., a_j} существует такое подмножество,
	 элементы которого в сумме дают i, и False - в противном случае.
	 Нужно определить, существует ли такое подмножество S, сумма элементов которого равна k/2
	*/
	dp := make([][]bool, (k/2)+1)
	for i := range dp {
		dp[i] = make([]bool, n+1)
	}

	/*
	 Верно следующее утверждение%
	 существует некоторое подмножество S, сумма которого равна i для чисел {a_1, ..., a_j},
	 тогда и только тогда, когда верно одно из двух:
	 - существует подмножество в {a_1, ..., a_(j-1)}, дающее сумму i;
	 - существует подмножество в {a_1, ..., a_(j-1)}, дающее сумму i-a_j, т.к. при добавлении a_j сумма
	   как раз будет равна i
	*/

	// Базовый случай:
	// 1. для суммы 0 можно выбрать любое подмножество
	for j := 0; j <= n; j++ {
		dp[0][j] = true
	}
	// 2. Набрать какую-нибудь сумму (кроме 0) из подмножества из нуля элементов невозможно
	for i := 1; i <= k/2; i++ {
		dp[i][0] = false
	}

	// заполняем таблицу dp
	for i := 1; i <= k/2; i++ {
		for j := 1; j <= n; j++ {
			if i-a[j] >= 0 {
				dp[i][j] = dp[i][j-1] || dp[i-a[j]][j-1]
			} else {
				dp[i][j] = dp[i][j-1]
			}
		}
	}

	// печатаем результат
	if dp[k/2][n] == true {
		fmt.Print("True")
	} else {
		fmt.Print("False")
	}
}
